//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* integrateKernelCL= \
"\n"
"float4 quatMult(float4 q1, float4 q2)\n"
"{\n"
"	float4 q;\n"
"	q.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;\n"
"	q.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;\n"
"	q.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;\n"
"	q.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z; \n"
"	return q;\n"
"}\n"
"\n"
"float4 quatNorm(float4 q)\n"
"{\n"
"	float len = native_sqrt(dot(q, q));\n"
"	if(len > 0.f)\n"
"	{\n"
"		q *= 1.f / len;\n"
"	}\n"
"	else\n"
"	{\n"
"		q.x = q.y = q.z = 0.f;\n"
"		q.w = 1.f;\n"
"	}\n"
"	return q;\n"
"}\n"
"\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	float4 m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"\n"
"	unsigned int m_collidableIdx;\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} Body;\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void \n"
"  integrateTransformsKernel( __global Body* bodies,const int numNodes, float timeStep, float angularDamping, float4 gravityAcceleration)\n"
"{\n"
"	int nodeID = get_global_id(0);\n"
"	float B3_GPU_ANGULAR_MOTION_THRESHOLD = (0.25f * 3.14159254f);\n"
"	if( nodeID < numNodes && (bodies[nodeID].m_invMass != 0.f))\n"
"	{\n"
"		//angular velocity\n"
"		{\n"
"			float4 axis;\n"
"			//add some hardcoded angular damping\n"
"			bodies[nodeID].m_angVel.x *= angularDamping;\n"
"			bodies[nodeID].m_angVel.y *= angularDamping;\n"
"			bodies[nodeID].m_angVel.z *= angularDamping;\n"
"			\n"
"			float4 angvel = bodies[nodeID].m_angVel;\n"
"			float fAngle = native_sqrt(dot(angvel, angvel));\n"
"			//limit the angular motion\n"
"			if(fAngle*timeStep > B3_GPU_ANGULAR_MOTION_THRESHOLD)\n"
"			{\n"
"				fAngle = B3_GPU_ANGULAR_MOTION_THRESHOLD / timeStep;\n"
"			}\n"
"			if(fAngle < 0.001f)\n"
"			{\n"
"				// use Taylor's expansions of sync function\n"
"				axis = angvel * (0.5f*timeStep-(timeStep*timeStep*timeStep)*0.020833333333f * fAngle * fAngle);\n"
"			}\n"
"			else\n"
"			{\n"
"				// sync(fAngle) = sin(c*fAngle)/t\n"
"				axis = angvel * ( native_sin(0.5f * fAngle * timeStep) / fAngle);\n"
"			}\n"
"			float4 dorn = axis;\n"
"			dorn.w = native_cos(fAngle * timeStep * 0.5f);\n"
"			float4 orn0 = bodies[nodeID].m_quat;\n"
"\n"
"			float4 predictedOrn = quatMult(dorn, orn0);\n"
"			predictedOrn = quatNorm(predictedOrn);\n"
"			bodies[nodeID].m_quat=predictedOrn;\n"
"		}\n"
"\n"
"		//linear velocity		\n"
"		bodies[nodeID].m_pos +=  bodies[nodeID].m_linVel * timeStep;\n"
"		\n"
"		//apply gravity\n"
"		bodies[nodeID].m_linVel += gravityAcceleration * timeStep;\n"
"		\n"
"	}\n"
"}\n"
"\n"
;
